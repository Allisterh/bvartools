---
title: "A Simple BVEC Estimatior"
author: "Franz X. Mohr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A Simple BVAR Estimatior}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This vignette provides the code to set up and estimate a basic Bayesian vector error correction (BVEC) model with the `bvartools` package.

## Data

To illustrate the estimation process the dataset E6 from Lütkepohl (2007) is used. It contains data on German long-term interest rates and inflation from 1972Q2 to 1998Q4.

```{r data, fig.align='center', fig.height=5, fig.width=4.5}
library(bvartools)

data("e6")

plot(e6) # Plot the series
```

The `gen_vec` function produces the inputs `Y`, `ECT` and `X` for the BVEC estimator, where `Y` is the matrix of dependent variables, `ECT` is a matrix of potentially cointegrated regressors, and `X` is the matrix of non-cointegration regressors.

```{r}
data <- gen_vec(e6, p = 4, const = "unrestricted", season = "unrestricted")

y <- data$Y
ect <- data$ECT
x <- data$X
```

## Estimation



```{r flat prior}
iter <- 20000 # Number of iterations of the Gibbs sampler
burnin <- 5000 # Number of burn-in draws
store <- iter - burnin

r <- 1 # Set rank

t <- ncol(y) # Number of observations
k <- nrow(y) # Number of endogenous variables
k_ect <- nrow(ect) # Number of regressors in error correction term
k_x <- nrow(x) # Number of differenced regressors and unrestrictec deterministic terms

k_alpha <- k * r # Number of elements in alpha
k_beta <- k_ect * r # Number of elements in beta
k_gamma <- k * k_x

# Set priors
A_mu_prior <- matrix(0, k_x * k) # Vector of prior parameter means
A_Sigma_i_prior <- diag(0, k_x * k) # Inverse of the prior covariance matrix

v_i <- 0
P_tau_i <- diag(1, k_ect)

Sigma_df_prior <- k + r # Prior degrees of freedom
Sigma_V_prior <- diag(.00001, k) # Prior covariance matrix
Sigma_df_post <- t + Sigma_df_prior # Posterior degrees of freedom

# Initial values
beta <- matrix(c(1, -4), k_ect, r)

Sigma_i_draw <- diag(.0001, k)#rWishart(1, Sigma_df_prior, solve(Sigma_V_prior))[,,1]
Sigma_draw <- solve(Sigma_i_draw)

G_i <- Sigma_i_draw

# Data containers
draws_alpha <- matrix(NA, k_alpha, store)
draws_beta <- matrix(NA, k_beta, store)
draws_Pi <- matrix(NA, k * k_ect, store)
draws_Gamma <- matrix(NA, k_gamma, store)
draws_Sigma <- matrix(NA, k^2, store)

# Start Gibbs sampler
for (draw in 1:iter) {
  # Draw conditional mean parameters
  temp <- post_koop_2010(y = y, beta = beta, ect = ect, x = x, Sigma_i = Sigma_i_draw,
                         Gamma_mu_prior = A_mu_prior, Gamma_V_i_prior = A_Sigma_i_prior,
                         v_i = v_i, P_tau_i = P_tau_i, G_i = G_i)
  alpha <- temp$alpha
  beta <- temp$beta
  Pi <- temp$Pi
  A_draw <- temp$Gamma
  
  # Draw variance-covariance matrix
  res <- y - Pi %*% ect - A_draw %*% x
  Sigma_V_post <- solve(Sigma_V_prior + tcrossprod(res))
  Sigma_i_draw <- rWishart(1, Sigma_df_post, Sigma_V_post)[,, 1]
  Sigma_draw <- solve(Sigma_i_draw)
  
  G_i <- Sigma_i_draw
  
  # Store draws
  if (draw > burnin) {
    draws_alpha[, draw - burnin] <- alpha
    draws_beta[, draw - burnin] <- beta
    draws_Pi[, draw - burnin] <- Pi
    draws_Gamma[, draw - burnin] <- A_draw
    draws_Sigma[, draw - burnin] <- Sigma_draw
  }
}
```

Obtain point estimates as the mean of the parameter draws:

```{r}
Gamma <- rowMeans(draws_Gamma) # Obtain means for every row
Gamma <- matrix(Gamma, k) # Transform mean vector into a matrix
Gamma <- round(Gamma, 3) # Round values
dimnames(Gamma) <- list(dimnames(y)[[1]], dimnames(x)[[1]]) # Rename matrix dimensions

Gamma # Print
```

```{r beta}
beta <- rowMeans(t(t(draws_beta) / t(draws_beta)[, 1])) # Obtain means for every row
beta <- matrix(beta, k_ect) # Transform mean vector into a matrix
beta <- round(beta, 3) # Round values
dimnames(beta) <- list(dimnames(ect)[[1]], NULL) # Rename matrix dimensions

beta # Print
```

```{r}
Sigma <- rowMeans(draws_Sigma) # Obtain means for every row
Sigma <- matrix(Sigma, k) # Transform mean vector into a matrix
Sigma <- round(Sigma * 10^4, 2) # Round values
dimnames(Sigma) <- list(dimnames(y)[[1]], dimnames(y)[[1]]) # Rename matrix dimensions

Sigma # Print
```

## `bvec` objects

The `bvec` function can be used to collect relevant output of the Gibbs sampler into a standardised object, which can be used by further function such as `irf` to obtain impulse responses.

```{r bvec-object}
bvec_est <- bvec(y = y, ect = ect, x = x,
                 alpha = draws_alpha, beta = draws_beta, Pi = draws_Pi,
                 Gamma = draws_Gamma[1:(6 * k),], D = draws_Gamma[(6 * k + 1):nrow(draws_Gamma),],
                 Sigma = draws_Sigma)
```

Use the function `bvec_to_bvar` to transform the VEC model to a VAR in levels:

```{r vec2var}
bvar_form <- bvec_to_bvar(bvec_est)
```

## Impulse response analysis

Impulse responses for VECs can be constructed from their VAR respresentations.

```{r feir, fig.width=5.5, fig.height=4.5}
IR <- irf(bvar_form, impulse = "R", response = "Dp", n.ahead = 20)

plot(IR, main = "Forecast Error Impulse Response", xlab = "Period", ylab = "Response")
```

### Orthogonalised impulse response

```{r oir, fig.width=5.5, fig.height=4.5}
OIR <- irf(bvar_form, impulse = "R", response = "Dp", n.ahead = 20, type = "oir")

plot(OIR, main = "Orthogonalised Impulse Response", xlab = "Period", ylab = "Response")
```

### Generalised impulse response

```{r gir, fig.width=5.5, fig.height=4.5}
GIR <- irf(bvar_form, impulse = "R", response = "Dp", n.ahead = 20, type = "gir")

plot(GIR, main = "Generalised Impulse Response", xlab = "Period", ylab = "Response")
```


## References

Koop, G., León-González, R., & Strachan R. W. (2010). Efficient posterior simulation for cointegrated models with priors on the cointegration space. *Econometric Reviews*, 29(2), 224-242. [https://doi.org/10.1080/07474930903382208](https://doi.org/10.1080/07474930903382208)

Luetkepohl, H. (2007). *New introduction to multiple time series analyis*. Berlin: Springer.

Pesaran, H. H., & Shin, Y. (1998). Generalized impulse response analysis in linear multivariate models, *Economics Letters*, 58, 17-29.

Plummer, M., Best, N., Cowles, K., & Vines, K. (2006). CODA: Convergence Diagnosis and Output Analysis for MCMC, R News, 6, 7-11. [https://www.r-project.org/doc/Rnews/Rnews_2006-1.pdf](https://www.r-project.org/doc/Rnews/Rnews_2006-1.pdf)